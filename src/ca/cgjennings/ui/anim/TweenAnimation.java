package ca.cgjennings.ui.anim;

import java.awt.EventQueue;

/**
 * A very simple animation with exactly three states: a start state, an end
 * state, and one tween frame. It operates in one of two modes. In the first
 * mode, it is assumed that the start state has already been in place for an
 * unknown amount of time. The animator will immediately apply the tween frame
 * and then (after allowing events generated by the tween frame to execute)
 * apply the end frame as soon as possible. In the second mode, called two-shot,
 * the start state is applied immediately, then the tween and end state are
 * composed in sequence as above.
 *
 * @author Chris Jennings <https://cgjennings.ca/contact>
 */
public abstract class TweenAnimation implements FrameComposer {

    private boolean twoShot;
    private boolean stopped, playing;
    private FrameComposer composer;

    public TweenAnimation() {
        this.composer = this;
        this.twoShot = false;
    }

    public TweenAnimation(boolean twoShot) {
        this.composer = this;
        this.twoShot = twoShot;
    }

    public TweenAnimation(boolean twoShot, FrameComposer composer) {
        this.composer = composer;
        this.twoShot = twoShot;
    }

    /**
     * Play the animation.
     */
    public void play() {
        if (playing) {
            stop();
            EventQueue.invokeLater(this::play);
        }

        stopped = false;
        playing = true;

        if (twoShot) {
            composeStart();
            EventQueue.invokeLater(() -> {
                if (!stopped) {
                    composeTween();
                }
            });
        } else {
            composeTween();
        }
        EventQueue.invokeLater(() -> {
            if (!stopped) {
                composeEnd();
            }
            playing = false;
        });
    }

    /**
     * Stop the animation as soon as possible if it is playing.
     */
    public void stop() {
        stopped = true;
    }

    /**
     * Returns <code>true</code> if the animation is stopped or stopping.
     *
     * @return <code>true</code> if the animation is or will be stopped
     */
    public boolean isStopped() {
        return stopped;
    }

    /**
     * Returns <code>true</code> if the animation is still playing. (This will
     * still be <code>true</code> after calling {@link #stop} until the
     * animation actually halts.)
     *
     * @return <code>true</code> if the animation is playing
     */
    public boolean isPlaying() {
        return playing;
    }

    /**
     * Override this to compose the initial frame in a two-shot. The base class
     * delegates to the installed composer with position 0.
     */
    public void composeStart() {
        composer.composeFrame(0f);
    }

    /**
     * Override this to compose the initial frame in a two-shot. The base class
     * delegates to the installed composer with position 0.5.
     */
    public void composeTween() {
        composer.composeFrame(0.5f);
    }

    /**
     * Override this to compose the initial frame in a two-shot. The base class
     * delegates to the installed composer with position 1.
     */
    public void composeEnd() {
        composer.composeFrame(1f);
    }

    /**
     * If {@link #composeStart}, {@link #composeTween}, and {@link #composeEnd}
     * are not overidden and no composer is set, this method is called to
     * compose the animation. The base class implementation does nothing.
     *
     * @param position
     */
    @Override
    public void composeFrame(float position) {
    }
}
