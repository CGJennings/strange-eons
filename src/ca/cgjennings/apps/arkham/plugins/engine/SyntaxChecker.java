package ca.cgjennings.apps.arkham.plugins.engine;

import ca.cgjennings.apps.arkham.editors.NavigationPoint;
import org.mozilla.javascript.EvaluatorException;
import org.mozilla.javascript.ast.AstRoot;
import org.mozilla.javascript.ast.IdeErrorReporter;
import ca.cgjennings.ui.textedit.ErrorHighlighter;
import ca.cgjennings.ui.textedit.HighlightedLine;
import ca.cgjennings.ui.textedit.JSourceCodeEditor;
import ca.cgjennings.ui.textedit.MarginNote;
import java.awt.Color;
import java.awt.Graphics2D;
import java.awt.event.MouseEvent;
import java.util.Collections;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.Set;
import javax.swing.JPopupMenu;
import javax.swing.UIManager;

/**
 * Determines the compile-time errors and warnings in a script without executing
 * the script.
 *
 * @author Chris Jennings <https://cgjennings.ca/contact>
 * @since 3.0
 */
public class SyntaxChecker extends AbstractUtilityParser {

    private LinkedList<SyntaxError> errors = new LinkedList<>();

    /**
     * Creates a new syntax checker.
     */
    public SyntaxChecker() {
        setErrorReporter(new IdeErrorReporter() {
            private void makeError(String message, boolean warning, int offset, int length) {
                if (message.length() > 0) {
                    message = Character.toUpperCase(message.charAt(0)) + message.substring(1);
                }
                if (acceptError(message, warning, offset, length)) {
                    errors.add(
                            new SyntaxError(message, warning, offset, length)
                    );
                }
            }

            @Override
            public void warning(String message, String sourceName, int line, String lineSource, int lineOffset) {
                throw new AssertionError();
            }

            @Override
            public void error(String message, String sourceName, int line, String lineSource, int lineOffset) {
                throw new AssertionError();
            }

            @Override
            public EvaluatorException runtimeError(String message, String sourceName, int line, String lineSource, int lineOffset) {
                throw new AssertionError();
            }

            @Override
            public void warning(String message, String sourceName, int offset, int length) {
                makeError(message, true, offset, length);
            }

            @Override
            public void error(String message, String sourceName, int offset, int length) {
                makeError(message, false, offset, length);
            }
        });
    }

    @Override
    public void parse(String script) {
        errors.clear();
        super.parse(script);
    }

    /**
     * Returns an array of the errors and warnings generated by the
     * most-recently parsed script.
     *
     * @return a (possibly empty) array of errors
     */
    public SyntaxError[] getErrors() {
        return errors.toArray(new SyntaxError[0]);
    }

    /**
     * Subclasses may use this to filter for specific error messages.
     *
     * @param message the error message
     * @param warning {@code true} if the message is a warning rather than an
     * error
     * @param offset the offset into the script
     * @param length the length of code that is affected
     * @return {@code true} if the error should be included in the results
     */
    protected boolean acceptError(String message, boolean warning, int offset, int length) {
        return WarningErrorReporter.acceptError(message, warning);
    }

    @Override
    protected void processTree(AstRoot rootNode) {
    }

    /**
     * Describes a syntax error that has been detected during syntax checking.
     * Provides a message, line number, column number, and differentiates
     * between errors and warnings.
     */
    public static final class SyntaxError {

        private int offset, length;
        private String message;
        private boolean warning;

        /**
         * Creates a new syntax error with the specified message, source
         * location, and error type.
         *
         * @param message the text of the error message
         * @param offset the offset from the document start at which the error
         * occurs
         * @param length the number of characters affected by the error
         * @param warning {@code true} if the error is a warning rather than a
         * true error
         */
        public SyntaxError(String message, boolean warning, int offset, int length) {
            this.offset = offset;
            this.length = length;
            this.message = message;
            this.warning = warning;
        }

        /**
         * Returns a string representation of the error.
         *
         * @return an error message string
         */
        @Override
        public String toString() {
            return message();
        }

        /**
         * Returns {@code true} if this error is a warning rather than a true
         * error.
         *
         * @return {@code true} for warning messages
         */
        public boolean isWarning() {
            return warning;
        }

        /**
         * Returns the offset from the document start where the error begins.
         *
         * @return the error start position
         */
        public int offset() {
            return offset;
        }

        /**
         * Returns the length of the region implicated in the error
         *
         * @return the length of the affected code
         */
        public int length() {
            return length;
        }

        /**
         * Returns the text of an error message that describes the error.
         *
         * @return the error message
         */
        public String message() {
            return message;
        }

        /**
         * Returns {@code true} if two errors are have identical locations,
         * messages, and error types.
         *
         * @param rhs the error to compare this error to
         * @return {@code true} if the errors are equal
         */
        public boolean equals(SyntaxError rhs) {
            return (rhs != null && offset == rhs.offset && length == rhs.length && warning == rhs.warning && message.equals(rhs.message));
        }

        @Override
        public boolean equals(Object rhs) {
            if (rhs == null || !(rhs instanceof SyntaxError)) {
                return false;
            }
            return equals((SyntaxError) rhs);
        }

        @Override
        public int hashCode() {
            int hash = 3;
            hash = 41 * hash + this.offset;
            hash = 41 * hash + this.length;
            hash = 41 * hash + (this.message != null ? this.message.hashCode() : 0);
            hash = 41 * hash + (this.warning ? 1 : 0);
            return hash;
        }
    }

    /**
     * A code highlighter that underlines syntax errors and warnings.
     */
    public static class Highlighter extends ErrorHighlighter {

        private Color warnColor;
        private Color errorColor;
        private SyntaxError[] errors;
        private HashSet<Integer> marked = new HashSet<>();
        private JSourceCodeEditor editor;

        /**
         * Creates a new syntax error highlighter.
         */
        public Highlighter() {
            warnColor = UIManager.getColor("nimbusAlertYellow");
            if (warnColor == null) {
                warnColor = new Color(0xffb629);
            }
            errorColor = UIManager.getColor("nimbusRed");
            if (errorColor == null) {
                errorColor = Color.RED;
            }
        }

        /**
         * Creates a new syntax error highlighter that underlines with the
         * specified colours.
         *
         * @param warnColor the colour for warnings
         * @param errorColor the colour for errors
         */
        public Highlighter(Color warnColor, Color errorColor) {
            this.warnColor = warnColor;
            this.errorColor = errorColor;
        }

        /**
         * Updates the highlighter with the current set of errors, as returned
         * from {@link #parse(java.lang.String)}.
         *
         * @param errors the new set of errors to display (may be {@code null})
         */
        public void update(JSourceCodeEditor editor, SyntaxError[] errors) {
            this.editor = editor;
            if (errors != this.errors) {
                this.errors = errors;
                marked.clear();
                if (errors != null) {
                    for (SyntaxError err : errors) {
                        marked.add(editor.getLineOfOffset(err.offset()));
                    }
                }
                editor.repaint();
            }
        }

        @Override
        public void paint(Graphics2D g, HighlightedLine hl) {
            int line = hl.line();
            if (marked.contains(line)) {
                int lineStart = hl.startOffset();
                int lineEnd = hl.endOffset();

                // paint warning lines first, then error lines
                boolean warning = true;
                for (;;) {
                    setColor(warning ? warnColor : errorColor);
                    for (SyntaxError err : errors) {
                        if (err.isWarning() == warning) {
                            int start = err.offset();
                            if (start >= lineStart && start < lineEnd) {
                                int end = Math.min(start + err.length(), lineEnd) - lineStart;
                                start -= lineStart;
                                paintErrorLine(g, hl, start, end);
                            }
                        }
                    }
                    if (warning == true) {
                        warning = false;
                    } else {
                        break;
                    }
                }
                restore(g);
            }
        }

        @Override
        public Set<MarginNote> getMarginNotes(int lineIndex) {
            Set<MarginNote> notes = null;
            if (marked.contains(lineIndex)) {
                int lineStart = editor.getLineStartOffset(lineIndex);
                int lineEnd = editor.getLineEndOffset(lineIndex);
                for (SyntaxError err : errors) {
                    int start = err.offset();
                    if (start >= lineStart && start < lineEnd) {
                        MarginNote note;
                        if (err.isWarning()) {
                            note = new MarginNote(NavigationPoint.ICON_WARNING, err.message(), MarginNote.LOW_PRIORITY);
                        } else {
                            note = new MarginNote(NavigationPoint.ICON_ERROR, err.message(), MarginNote.HIGH_PRIORITY);
                        }
                        if (notes == null) {
                            notes = Collections.singleton(note);
                        } else {
                            if (notes.size() == 1) {
                                notes = new HashSet<>(notes);
                            }
                            notes.add(note);
                        }
                    }
                }
            }
            return notes;
        }

        @Override
        public String getToolTipText(MouseEvent e) {
            return null;
        }

        @Override
        public JPopupMenu getPopupMenu(MouseEvent e, HighlightedLine hl) {
            return null;
        }
    }
}
