package ca.cgjennings.apps.arkham.plugins.engine;

import org.mozilla.javascript.EvaluatorException;
import org.mozilla.javascript.ast.AstRoot;
import org.mozilla.javascript.ast.IdeErrorReporter;
import java.util.LinkedList;

/**
 * Determines the compile-time errors and warnings in a script without executing
 * the script.
 *
 * @author Chris Jennings <https://cgjennings.ca/contact>
 * @since 3.0
 */
public class SyntaxChecker extends AbstractUtilityParser {

    private LinkedList<SyntaxError> errors = new LinkedList<>();

    /**
     * Creates a new syntax checker.
     */
    public SyntaxChecker() {
        setErrorReporter(new IdeErrorReporter() {
            private void makeError(String message, boolean warning, int offset, int length) {
                if (message.length() > 0) {
                    message = Character.toUpperCase(message.charAt(0)) + message.substring(1);
                }
                if (acceptError(message, warning, offset, length)) {
                    errors.add(
                            new SyntaxError(message, warning, offset, length)
                    );
                }
            }

            @Override
            public void warning(String message, String sourceName, int line, String lineSource, int lineOffset) {
                throw new AssertionError();
            }

            @Override
            public void error(String message, String sourceName, int line, String lineSource, int lineOffset) {
                throw new AssertionError();
            }

            @Override
            public EvaluatorException runtimeError(String message, String sourceName, int line, String lineSource, int lineOffset) {
                throw new AssertionError();
            }

            @Override
            public void warning(String message, String sourceName, int offset, int length) {
                makeError(message, true, offset, length);
            }

            @Override
            public void error(String message, String sourceName, int offset, int length) {
                makeError(message, false, offset, length);
            }
        });
    }

    @Override
    public void parse(String script) {
        errors.clear();
        super.parse(script);
    }

    /**
     * Returns an array of the errors and warnings generated by the
     * most-recently parsed script.
     *
     * @return a (possibly empty) array of errors
     */
    public SyntaxError[] getErrors() {
        return errors.toArray(SyntaxError[]::new);
    }

    /**
     * Subclasses may use this to filter for specific error messages.
     *
     * @param message the error message
     * @param warning {@code true} if the message is a warning rather than an
     * error
     * @param offset the offset into the script
     * @param length the length of code that is affected
     * @return {@code true} if the error should be included in the results
     */
    protected boolean acceptError(String message, boolean warning, int offset, int length) {
        return WarningErrorReporter.acceptError(message, warning);
    }

    @Override
    protected void processTree(AstRoot rootNode) {
    }

    /**
     * Describes a syntax error that has been detected during syntax checking.
     * Provides a message, line number, column number, and differentiates
     * between errors and warnings.
     */
    public static final class SyntaxError {

        private int offset, length;
        private String message;
        private boolean warning;

        /**
         * Creates a new syntax error with the specified message, source
         * location, and error type.
         *
         * @param message the text of the error message
         * @param offset the offset from the document start at which the error
         * occurs
         * @param length the number of characters affected by the error
         * @param warning {@code true} if the error is a warning rather than a
         * true error
         */
        public SyntaxError(String message, boolean warning, int offset, int length) {
            this.offset = offset;
            this.length = length;
            this.message = message;
            this.warning = warning;
        }

        /**
         * Returns a string representation of the error.
         *
         * @return an error message string
         */
        @Override
        public String toString() {
            return message();
        }

        /**
         * Returns {@code true} if this error is a warning rather than a true
         * error.
         *
         * @return {@code true} for warning messages
         */
        public boolean isWarning() {
            return warning;
        }

        /**
         * Returns the offset from the document start where the error begins.
         *
         * @return the error start position
         */
        public int offset() {
            return offset;
        }

        /**
         * Returns the length of the region implicated in the error
         *
         * @return the length of the affected code
         */
        public int length() {
            return length;
        }

        /**
         * Returns the text of an error message that describes the error.
         *
         * @return the error message
         */
        public String message() {
            return message;
        }

        /**
         * Returns {@code true} if two errors are have identical locations,
         * messages, and error types.
         *
         * @param rhs the error to compare this error to
         * @return {@code true} if the errors are equal
         */
        public boolean equals(SyntaxError rhs) {
            return (rhs != null && offset == rhs.offset && length == rhs.length && warning == rhs.warning && message.equals(rhs.message));
        }

        @Override
        public boolean equals(Object rhs) {
            if (rhs == null || !(rhs instanceof SyntaxError)) {
                return false;
            }
            return equals((SyntaxError) rhs);
        }

        @Override
        public int hashCode() {
            int hash = 3;
            hash = 41 * hash + this.offset;
            hash = 41 * hash + this.length;
            hash = 41 * hash + (this.message != null ? this.message.hashCode() : 0);
            hash = 41 * hash + (this.warning ? 1 : 0);
            return hash;
        }
    }
}
