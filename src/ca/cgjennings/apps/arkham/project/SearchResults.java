package ca.cgjennings.apps.arkham.project;

import ca.cgjennings.apps.arkham.StrangeEons;
import ca.cgjennings.apps.arkham.StrangeEonsAppWindow;
import ca.cgjennings.apps.arkham.StrangeEonsEditor;
import ca.cgjennings.apps.arkham.TrackedWindow;
import ca.cgjennings.apps.arkham.dialog.ErrorDialog;
import ca.cgjennings.apps.arkham.editors.CodeEditor;
import ca.cgjennings.ui.DefaultTreeCellRenderer;
import ca.cgjennings.ui.JUtilities;
import ca.cgjennings.ui.TreeLabelExposer;
import ca.cgjennings.ui.textedit.JSourceCodeEditor;
import java.awt.Color;
import java.awt.Component;
import java.awt.EventQueue;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.io.File;
import java.io.IOException;
import java.util.HashMap;
import java.util.regex.Pattern;
import javax.swing.Icon;
import javax.swing.JMenuItem;
import javax.swing.JPopupMenu;
import javax.swing.JTree;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.DefaultTreeModel;
import javax.swing.tree.TreePath;
import resources.Language;
import static resources.Language.string;
import resources.ResourceKit;

/**
 * A dialog that displays the result of searching a project.
 *
 * @author Chris Jennings <https://cgjennings.ca/contact>
 */
@SuppressWarnings("serial")
class SearchResults extends javax.swing.JDialog implements Searcher.ResultReceiver, StrangeEonsAppWindow.ProjectEventListener, TrackedWindow {

    public SearchResults(String title, Member parent, Pattern pattern) {
        super(StrangeEons.getWindow(), title, false);
        JUtilities.makeUtilityWindow(this);
        initComponents();
        new TreeLabelExposer(results);
        results.setCellRenderer(new Renderer());
        getRootPane().getContentPane().setBackground(Color.WHITE);
        getRootPane().setBackground(Color.WHITE);

        root = new DefaultMutableTreeNode();
        root.setUserObject(string("prj-l-search-no-matches"));
        model = new DefaultTreeModel(root, true);
        results.setModel(model);
        setFocusableWindowState(false);
        StrangeEons.getWindow().addProjectEventListener(this);
        matches = 0;

        results.addMouseListener(new MouseAdapter() {
            @Override
            public void mouseClicked(MouseEvent evt) {
                if (evt.getButton() == MouseEvent.BUTTON1 && evt.getClickCount() == 2) {
                    TreePath selPath = results.getSelectionPath();
                    if (selPath == null || selPath.getLastPathComponent() == root) {
                        return;
                    }
                    Node sel = (Node) selPath.getLastPathComponent();
                    if (sel == root) {
                        return;
                    }
                    openResult((Result) sel.getUserObject());
                }
            }

            @Override
            public void mousePressed(MouseEvent evt) {
                if (evt.isPopupTrigger()) {
                    showPopup(evt);
                }
            }

            @Override
            public void mouseReleased(MouseEvent evt) {
                if (evt.isPopupTrigger()) {
                    showPopup(evt);
                }
            }

            private void showPopup(MouseEvent evt) {
                TreePath selPath = results.getPathForLocation(evt.getX(), evt.getY());
                if (selPath == null) {
                    return;
                }
                results.setSelectionPath(selPath);
                Node sel = (Node) selPath.getLastPathComponent();
                if (sel == root) {
                    return;
                }
                showPopupMenuForResult((Result) sel.getUserObject(), evt.getX(), evt.getY());
            }
        });

        searcher = new Searcher(parent, pattern, this, 100);
        StrangeEons.getWindow().startTracking(this);
    }

    @Override
    public Icon getIcon() {
        return ResourceKit.getIcon("application/result-window.png");
    }

    private DefaultMutableTreeNode root;
    private DefaultTreeModel model;
    private Searcher searcher;
    private int matches;

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        progress = new javax.swing.JProgressBar();
        jScrollPane1 = new javax.swing.JScrollPane();
        results = new javax.swing.JTree();

        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);

        progress.setBackground(java.awt.Color.white);
        progress.setIndeterminate(true);
        progress.setOpaque(true);
        getContentPane().add(progress, java.awt.BorderLayout.SOUTH);

        jScrollPane1.setBorder(null);

        results.setBorder(javax.swing.BorderFactory.createEmptyBorder(6, 6, 6, 6));
        results.setFont(results.getFont().deriveFont(results.getFont().getSize()-1f));
        results.setShowsRootHandles(false);
        jScrollPane1.setViewportView(results);

        getContentPane().add(jScrollPane1, java.awt.BorderLayout.CENTER);

        pack();
    }// </editor-fold>//GEN-END:initComponents

    @Override
    public void dispose() {
        StrangeEons.getWindow().removeProjectEventListener(this);
        if (searcher != null) {
            searcher.cancel();
            searcher = null;
        }
        StrangeEons.getWindow().stopTracking(this);
        super.dispose();
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JProgressBar progress;
    private javax.swing.JTree results;
    // End of variables declaration//GEN-END:variables

    private int matchLimit = 5_000;

    @Override
    public void addResult(final Searcher source, final Member member, final int line, String context, final int start, final int end) {
        final Result result = new Result(member, line, context, start, end);
        EventQueue.invokeLater(() -> {
            String matchesFound = String.format(Language.getInterface().getPluralizer().pluralize(++matches, "prj-l-search-matches"), matches);
            if (matches >= matchLimit) {
                source.cancel();
                matchesFound = string("prj-l-search-matches-too-many", matchesFound);
                progress.setVisible(false);
            }
            root.setUserObject(matchesFound);
            model.nodeChanged(root);
            if (matches >= matchLimit) {
                return;
            }
            Node parent1 = parentNodes.get(result.member);
            if (parent1 == null) {
                if (line == 0) {
                    // match is in file name
                    parent1 = new Node(result);
                } else {
                    parent1 = new Node(new Result(member, 0, null, -1, -1));
                }
                parentNodes.put(result.member, parent1);
                model.insertNodeInto(parent1, root, root.getChildCount());
            }
            if (result.line > 0) {
                model.insertNodeInto(new Node(result), parent1, parent1.getChildCount());
            }
        });
    }

    @Override
    public void setFileCount(Searcher source, final int count) {
        EventQueue.invokeLater(() -> {
            progress.setIndeterminate(false);
            progress.setMaximum(count);
            gotFileCount = true;
        });
    }
    private boolean gotFileCount = false;

    @Override
    public void setFinishedFileCount(Searcher source, final int fileCount) {
        EventQueue.invokeLater(() -> {
            progress.setValue(fileCount);
            if (gotFileCount && (fileCount == progress.getMaximum())) {
                progress.setVisible(false);
            }
        });
    }

    @Override
    public void searchCompleted(Searcher source) {
        progress.setVisible(false);
        searcher = null;
    }

    @Override
    public void projectOpened(Project proj) {
    }

    @Override
    public void projectClosing(Project proj) {
        dispose();
    }

    private HashMap<Member, Node> parentNodes = new HashMap<>();

    private static class Result {

        private Member member;
        private int line, start, end;
        private Icon icon;
        private String label;
        private String context;

        public Result(Member member, int line, String context, int start, int end) {
            this.member = member;
            this.line = line;
            this.start = start;
            this.end = end;
            this.context = context;
        }

        @Override
        public String toString() {
            if (label == null) {
                init();
            }
            return label;
        }

        public Icon getIcon() {
            if (icon == null) {
                init();
            }
            return icon;
        }

        private void init() {
            if (line > 0) {
                initHit();
            } else {
                initFile();
            }
        }

        private void initFile() {
            String relpath = null;
            ProjectView v = ProjectView.getCurrentView();
            if (v != null) {
                Project p = v.getProject();
                icon = member.getIcon();
                relpath = ProjectUtilities.makeFileRelativeTo(p.getFile(), member.getFile()).toString();
            }
            StringBuilder b = new StringBuilder("<html>");
            if (line == 0 && start >= 0) {
                appendMatch(b, member.getFile().getName());
            } else {
                b.append(member.getFile().getName());
            }

            if (relpath != null) {
                b.append(" <span style='color: #777777'>")
                        .append(relpath)
                        .append("</span>");
            }
            label = b.toString();
        }

        private void initHit() {
            StringBuilder b = new StringBuilder("<html>");
            b.append(line).append(" : ");
            appendMatch(b, context);
            label = b.toString();
        }

        private static final int CONTEXT_STRING_LENGTH = 80;

        private void appendMatch(StringBuilder b, String text) {
            appendQuoted(b, text, Math.max(0, start - CONTEXT_STRING_LENGTH / 2), start, -1);
            b.append("<span style='background-color: #fee800'>");
            appendQuoted(b, text, start, end, 0);
            b.append("</span>");
            appendQuoted(b, text, end, Math.min(end + CONTEXT_STRING_LENGTH, text.length()), 1);
        }

        private void appendQuoted(StringBuilder b, String text, int start, int end, int matchPart) {
            if (matchPart < 0 && start > 0) {
                b.append("...");
            }
            for (int i = start; i < end; ++i) {
                char c = text.charAt(i);
                switch (c) {
                    case '&':
                        b.append("&amp;");
                        break;
                    case '<':
                        b.append("&lt;");
                        break;
                    case '>':
                        b.append("&gt;");
                        break;
                    default:
                        b.append(c);
                }
            }
            if (matchPart > 0 && end < text.length()) {
                b.append("...");
            }
        }
    }

    private static class Node extends DefaultMutableTreeNode {

        public Node(Result r) {
            setUserObject(r);
        }

        @Override
        public boolean getAllowsChildren() {
            return getChildCount() > 0;
        }
    }

    protected void showPopupMenuForResult(final Result result, int x, int y) {
        final ProjectView view = ProjectView.getCurrentView();
        if (view == null) {
            return;
        }
        Project proj = view.getProject();
        if (result.member.getProject() != proj) {
            return;
        }
        Member[] members = new Member[]{result.member};
        JPopupMenu menu = Actions.buildMenu(members);

        JMenuItem selectItem = new JMenuItem(string("app-pu-select"));
        selectItem.addActionListener((ActionEvent e) -> {
            view.select(result.member);
            view.ensureVisible(result.member);
        });
        menu.add(selectItem, 0);
        menu.add(new JPopupMenu.Separator(), 1);

        menu.show(results, x, y);
    }

    protected void openResult(Result result) {
        ProjectView view = ProjectView.getCurrentView();
        if (view == null) {
            return;
        }

        Project proj = view.getProject();
        Member member = result.member;
        File f = member.getFile();

        // special case for "opening" a folder: select it in the project pane
        if (member.isFolder()) {
            view.expandFolder(member);
            view.clearSelection();
            view.addToSelection(member);
            view.requestFocusInWindow();
            return;
        }

        TaskAction ta = Actions.getUnspecializedAction("open");
        if (ta == null || !(ta instanceof Open)) {
            return;
        }
        Open open = (Open) ta;

        StrangeEonsEditor[] eds = StrangeEons.getWindow().getEditorsShowingFile(f);
        if (eds.length == 0) {
            try {
                boolean ok = open.tryInternalOpen(proj, member, f);
                // if opening an .eon file it won't open until the queue cycles
                StrangeEons.getWindow().openFile(f);
                if (result.line < 1) {
                    return;
                }

                eds = StrangeEons.getWindow().getEditorsShowingFile(f);
                if (eds.length == 0) {
                    throw new IOException("unexpected failure while creating editor");
                }
            } catch (IOException e) {
                ErrorDialog.displayError(string("prj-err-open", f.getName()), e);
                return;
            }
        }
        if (eds[0] instanceof CodeEditor && result.line >= 1) {
            JSourceCodeEditor editor = ((CodeEditor) eds[0]).getEditor();
            int sol = editor.getLineStartOffset(result.line - 1);
            if (sol >= 0 && result.start > 0) {
                editor.select(sol + result.start, sol + result.end);
            }
        }
        eds[0].select();
    }

    private class Renderer extends DefaultTreeCellRenderer {

        @Override
        public Component getTreeCellRendererComponent(JTree tree, Object value, boolean sel, boolean expanded, boolean leaf, int row, boolean hasFocus) {
            super.getTreeCellRendererComponent(tree, value, sel, expanded, leaf, row, hasFocus);
            if (value instanceof Node) {
                Result r = (Result) ((Node) value).getUserObject();
                setIcon(r.icon);
            } else {
                setIcon(findIcon);
            }
            return this;
        }
    }
    private Icon findIcon = ResourceKit.getIcon("ui/find.png");
}
